% === Section IX: Conclusion ===
\section{Conclusion}
\label{sec:conclusion}

We have shown that two declarative frameworks---sparse linear algebra
and relational algebra---target the same CSR storage and
the same sorted-intersection primitives, but differ fundamentally in
what they can express.  Sparse linear algebra decomposes triangle
counting into pairwise matrix operations (SpMM + mask); relational
algebra fuses the three-relation join into a single pass.  The fused
kernel, derived mechanically from the Leapfrog Triejoin, is
instruction-for-instruction identical to the hand-written CSR triangle
counting code that HPC programmers have long used.

This equivalence has two implications.  First, the hand-written CSR
algorithm---previously an ad~hoc construction---is in fact a
worst-case optimal join, inheriting the $\Oh(M^{3/2})$ AGM bound
guarantee.  Second, the pairwise SpMM approach is provably suboptimal
for triangle counting: it cannot avoid the $\Oh(M^2)$ intermediate
that the fused approach eliminates.  This limitation is structural,
not an implementation artifact---Wang et al.~\cite{wang2020spores}
proved that relational algebra rewrites are strictly more powerful
than linear algebra rewrites, and no amount of lazy evaluation within
the pairwise linear algebra framework can recover the fused kernel
(Section~\ref{sec:lazy}).

These results extend beyond triangles.  As
Section~\ref{sec:beyond} demonstrates, the masked SpGEMM technique
that partially closes the gap for triangles does not generalize: for
4-cycles, diamonds, bow-ties, and $k$-cycles, no natural mask exists,
and the pairwise approach is stuck at $\Oh(M^2)$ while WCOJ achieves
$\Oh(M^{3/2})$ or better.  The dividing line is the cyclicity of the
query hypergraph---any graph pattern containing a cycle requires
multiway intersection for optimal evaluation, and pairwise matrix
operations are structurally limited to binary join plans.

Worst-case optimal joins thus provide a principled path from
declarative graph-pattern queries to provably optimal code, with zero
abstraction overhead when the underlying storage is CSR\@.  The WCOJ
framework handles arbitrary cyclic join patterns, a capability that
pairwise matrix operations fundamentally lack.
